//---------------------------------------------------------------------------------------Определения-----------------------------------------------------------------------------------------

#define CLK 13 // подключаем импульсы отсчета энкодера на 13-й цифровой пин (можно и на аналоговый - без разницы) - т.е. насколько сильно повернули энкодер
#define DT  12 // подключаем импульсы направления энкодера на 12-й цифровой пин (можно и на аналоговый - без разницы) - т.е. в какую сторону повернули энкодер
#define SW  11 // подключаем кнопку энкодера на 11-й цифровой пин (можно и на аналоговый - без разницы)

#define PERIOD 500 // период переключения (мс) - для термопары

#define thermoSO 5 // подключение SO модуля MAX6675 на 5 цифровой пин
#define thermoCS 6 // подключение CS модуля MAX6675 на 6 цифровой пин
#define thermoCLK 7 // подключение SCK модуля MAX6675 на 7 цифровой пин

//----------------------------------------------------------------------------------Подключение библиотек------------------------------------------------------------------------------------

#include <Wire.h> // подключаем библиотеку для работы с шиной I2C
#include <LiquidCrystal_I2C.h> // подключаем библиотеку для работы дисплея по шине I2C
#include <max6675.h> // подключаем библиотеку для работы с термопарным модулем
#include <GyverPID.h> // подключаем библиотеку для работы с ПИД-регулятором
#include <GyverEncoder.h> // подключаем библиотеку для энкодера
#include <EEPROMex.h> // подключаем библиотеку для сохранения в памяти значений перед отключением питания

//----------------------------------------------------------------------------------Объявление переменных------------------------------------------------------------------------------------

volatile int T_set = 30; // переменная для установки температуры, в которую динамически будет вписываться значение, полученное с вращения энкодера
volatile int screenState = 0; // переменная для состояний экрана: 0 - главное меню (по умолчанию), 1 - установка таймера, 2 - ввод  Kp, 3 - ввод Ki, 4 - ввод Kd, 5 - проведение эксперимента
volatile int T_current; // для пересчёта переменной выше на температуру

volatile long timer_set = 360; // переменная для установки таймера (в мин), в которую динамически будет вписываться значение, полученное с вращения энкодера (по умолчанию = 6 часов)
volatile unsigned long timer; // постоянно обновляемая переменная для таймера (пищалки)
volatile unsigned long t=0; // тоже нужно для пищалки

uint32_t TIMER = 0; // еще одна переменная таймера

uint8_t degree[8] = {140,146,146,140,128,128,128,128}; // определяем массив хрянящий биты символа градуса

const int ledPin = 9; // пока просто светодиод вместо силовой
const int soundPin = A2; // номер аналогового пина, на который подключен буззер (пищалка)
const int On_Off_Button = 2; // номер цифрового пина, на который подключена кнопка СТАРТ/СТОП

boolean lastButton = LOW;
boolean currentButton = LOW;
boolean ledOn = false;

volatile float Kp = EEPROM.readFloat(100); // считать значение из 100-й ячейки
volatile float Ki = EEPROM.readFloat(200); // считать значение из 200-й ячейки
volatile float Kd = EEPROM.readFloat(300); // считать значение из 300-й ячейки
volatile int T_SET = EEPROM.readInt(400); // считать значение из 400-й ячейки

//------------------------------------------------------------------------------Создание экземпляров классов---------------------------------------------------------------------------------

LiquidCrystal_I2C lcd(0x27, 16, 2); // объявляем  объект библиотеки, указывая параметры дисплея (адрес I2C = 0x27, количество столбцов = 16, количество строк = 2)
Encoder enc(CLK, DT, SW); // инициализация энкодера, enc - выбранное мной название для создаваемого с помощью соответствующей библиотеки экземпляра класса Encoder
GyverPID regulator(0.1, 0.05, 0.01, 100); // сообщаем регулятору коэф-ты П, И, Д, и период дискретизации (мс)
MAX6675 thermocouple(thermoCLK, thermoCS, thermoSO); // создание объекта класса для модуля термопары MAX6675

//======================================================================================УСТАНОВКА============================================================================================

void setup() {

  enc.setType(TYPE2); // выбор типа энкодера, если работает странно, то сменить тип на TYPE1
  enc.setFastTimeout(110); // таймаут на скорость isFast (о умолчанию 50)

  Serial.begin(9600);

  pinMode(ledPin, OUTPUT);
  pinMode(On_Off_Button, INPUT);
  pinMode(soundPin, OUTPUT);

  if (Kp != 0.1 || Ki != 0.05 || Kd != 0.01 || T_SET != 30){ // проверка на отличие коэф-в от их значений по умолчанию
    regulator.kp = Kp; 
    regulator.ki = Ki;
    regulator.kd = Kd;
    T_set = T_SET;
  }

  // установка дисплея
  lcd.begin(); // инициализация ЖК-дисплея
  lcd.backlight(); // включение подсветки дисплея
  lcd.createChar(1, degree); // загружаем массив с символом градуса «°» в 1 ячейку ОЗУ дисплея

  // установка параметров регулирования (задание температуры)
  regulator.setDirection(NORM); // направление регулирования: NORMAL (0) или REVERSE (1)
  regulator.setLimits(0, 255); // пределы (ставим для 8 битного ШИМ)
  regulator.setpoint = T_set; // сообщаем регулятору температуру, которую он должен поддерживать

  // загурзка  стартового окна
  lcd.clear();
  lcd.print("   Loading...   ");
  delay(2000);
  screen_Main_Menu();
  
}

//=====================================================================================ГЛАВНЫЙ ЦИКЛ==========================================================================================

void loop() {
  
  switch (screenState) { // выбор нужного экрана (изначально screen было равно 0)
    case 0: // главное меню - дописать обработку отдельной кнопки СТАРТ/СТОП
      noTone(soundPin);
      enc.tick(); // обязательная функция отработки энкодера, должна постоянно опрашиваться
      if (millis() - TIMER >= PERIOD) { // вывод значений термопары 2 раза в секунду
        
        // обработчик действий для термопары
        T_current = thermocouple.readCelsius(); // пересчёт на текущую температуру, в эту переменную будет записываться значение с термодатчика (термопары)
        screen_Main_Menu();
        
        do {
          TIMER += PERIOD;
          if (TIMER < PERIOD) break; // переполнение uint32_t
        } while (TIMER < millis() - PERIOD); // защита от пропуска шага
      }
      if (enc.isRight()) {
        T_set++; // если энкодер был повернут вправо, то увеличить устанавливаемую температуру на единицу
        screen_Main_Menu();
      }
      if (enc.isLeft()) {
        T_set--; // если энкодер был повернут вправо, то уменьшить устанавливаемую температуру на единицу
        screen_Main_Menu();
      }
      if (enc.isFastR()) {
        T_set = T_set + 10; // если энкодер был быстро повернут вправо, то увеличить устанавливаемую температуру на 10
        screen_Main_Menu();   
      }
      if (enc.isFastL()) {
        T_set = T_set - 10; // если энкодер был быстро повернут вправо, то уменьшить устанавливаемую температуру на 10
        screen_Main_Menu(); 
      }
      if (enc.isClick() ) {
        screenState = 1; // если было нажатие на кнопку энкодера, то смена экрана главного меню на экран установки таймера
        screen_Set_Timer();
        break;
      }
      if (enc.isHolded()) {
        screenState = 2; // если кнопка энкодера удерживалась, то переход в меню настройки коэффициентов ПИД-регулятора, в частности к настройке коэффициента П
        screen_Set_P();
        break;
      }
      
      // отработка нажатия на кнопку с переходом в режим регулирования
      currentButton = debounce(lastButton);
      if (lastButton == LOW && currentButton == HIGH){ // если было нажатие на кнопку, то...
        timer = millis(); // запустить таймер
        screenState = 5; 
        ledOn = !ledOn;

        // сохранение температуры
        T_SET = T_set;
        EEPROM.updateInt(400, T_SET);
        
        screen_Experiment(); // показать экран регулирования
      }
      lastButton = currentButton; // сменить состояние кнопки
      digitalWrite(ledPin, ledOn); // включить светодиод
      break;
    case 1: // экран установки таймера
      enc.tick(); // обязательная функция отработки энкодера, должна постоянно опрашиваться
      if (enc.isRight()) {
        timer_set++; // если был поворот вправо, то прибавить минуту
        screen_Set_Timer();
      }
      if (enc.isLeft()) {
        timer_set--; // если был поворот влево, то убавить минуту
        if (timer_set < 0) timer_set = 0; // нижний порог - 0
        screen_Set_Timer();
      }
      if (enc.isFastR()) {
        timer_set = timer_set + 10; // если энкодер был быстро повернут вправо, то увеличить устанавливаемое время на 10 минут
        screen_Set_Timer();  
      }
      if (enc.isFastL()) {
        timer_set = timer_set - 10; // если энкодер был быстро повернут влево, то уменьшить устанавливаемое время на 10 минут
        if (timer_set < 0) timer_set = 0; // нижний порог - 0
        screen_Set_Timer(); 
      }
      if (enc.isRightH()) {
        timer_set = timer_set + 60;
        screen_Set_Timer();
      }
      if (enc.isLeftH()) {
        timer_set = timer_set - 60;
        if (timer_set < 0) timer_set = 0; // нижний порог - 0
        screen_Set_Timer();
      }
      if (enc.isClick() ) {
        screenState = 0; // если было нажатие на кнопку энкодера, то переход обратно в главное меню
        screen_Main_Menu();
        break;
      }
      if (enc.isHolded()) {
        screenState = 2; // если кнопка энкодера удерживалась, то переход в меню настройки коэффициентов ПИД-регулятора, в частности к настройке коэффициента П
        screen_Set_P();
        break;
      }
      break;
    case 2: // экран установки П-составляющей
      enc.tick(); // обязательная функция отработки энкодера, должна постоянно опрашиваться
      if (enc.isRight()) {
        regulator.kp += 0.01;
        screen_Set_P();
      }
      if (enc.isLeft()) {
        regulator.kp -= 0.01;
        screen_Set_P();
      }
      if (enc.isFastR()) {
        regulator.kp = regulator.kp + 0.1; // если энкодер был быстро повернут вправо, то увеличить на 0.1
        screen_Set_P();  
      }
      if (enc.isFastL()) {
        regulator.kp = regulator.kp - 0.1; // если энкодер был быстро повернут влево, то уменьшить на 0.1
        screen_Set_P(); 
      }
      if (enc.isRightH()) {
        regulator.kp++;
        screen_Set_P();
      }
      if (enc.isLeftH()) {
        regulator.kp--;
        screen_Set_P();
      }
      if (enc.isClick() ) {
        screenState = 3; // если было нажатие на кнопку энкодера, то смена экрана настройки пропорциональной составляющей на экран установки интегральной составляющей
        screen_Set_I();
        break;
      }
      if (enc.isHolded()) { // прописать в этом блоке сохранение данных
        screenState = 0; // если кнопка энкодера удерживалась, то переход в главное меню
        Kp = regulator.kp;
        Ki = regulator.ki;
        Kd = regulator.kd;
        EEPROM.updateFloat(100, Kp);
        EEPROM.updateFloat(200, Ki);
        EEPROM.updateFloat(300, Kd);
        screen_Main_Menu();
        break;
      }
      break;
    case 3: // экран установки И-составляющей
      enc.tick(); // обязательная функция отработки энкодера, должна постоянно опрашиваться
      if (enc.isRight()) {
        regulator.ki += 0.01;
        screen_Set_I();
      }
      if (enc.isLeft()) {
        regulator.ki -= 0.01;
        screen_Set_I();
      }
      if (enc.isFastR()) {
        regulator.ki = regulator.ki + 0.1; // если энкодер был быстро повернут вправо, то увеличить на 0.1
        screen_Set_I();  
      }
      if (enc.isFastL()) {
        regulator.ki = regulator.ki - 0.1; // если энкодер был быстро повернут влево, то уменьшить на 0.1
        screen_Set_I(); 
      }
      if (enc.isRightH()) {
        regulator.ki++;
        screen_Set_I();
      }
      if (enc.isLeftH()) {
        regulator.ki--;
        screen_Set_I();
      }
      if (enc.isClick() ) {
        screenState = 4; // если было нажатие на кнопку энкодера, то смена экрана настройки интегральной составляющей на экран установки дифференциальной составляющей
        screen_Set_D();
        break;
      }
      if (enc.isHolded()) {
        screenState = 0; // если кнопка энкодера удерживалась, то переход в главное меню
        Kp = regulator.kp;
        Ki = regulator.ki;
        Kd = regulator.kd;
        EEPROM.updateFloat(100, Kp);
        EEPROM.updateFloat(200, Ki);
        EEPROM.updateFloat(300, Kd);
        screen_Main_Menu();
        break;
      }
      break;
    case 4: // экран установки Д-составляющей
      enc.tick(); // обязательная функция отработки энкодера, должна постоянно опрашиваться
      if (enc.isRight()) {
        regulator.kd += 0.01;
        screen_Set_D();
      }
      if (enc.isLeft()) {
        regulator.kd -= 0.01;
        screen_Set_D();
      }
      if (enc.isFastR()) {
        regulator.kd = regulator.kd + 0.1; // если энкодер был быстро повернут вправо, то увеличить на 0.1
        screen_Set_D();  
      }
      if (enc.isFastL()) {
        regulator.kd = regulator.kd - 0.1; // если энкодер был быстро повернут влево, то уменьшить на 0.1
        screen_Set_D(); 
      }
      if (enc.isRightH()) {
        regulator.kd++;
        screen_Set_D();
      }
      if (enc.isLeftH()) {
        regulator.kd--;
        screen_Set_D();
      }
      if (enc.isClick()) {
        screenState = 2; // если было нажатие на кнопку энкодера, то смена экрана настройки дифференциальной составляющей на экран установки пропорциональной составляющей
        screen_Set_P();
        break;
      }
      if (enc.isHolded()) {
        screenState = 0; // если кнопка энкодера удерживалась, то переход в главное меню
        Kp = regulator.kp;
        Ki = regulator.ki;
        Kd = regulator.kd;
        EEPROM.updateFloat(100, Kp);
        EEPROM.updateFloat(200, Ki);
        EEPROM.updateFloat(300, Kd);
        screen_Main_Menu();
        break;
      }
      break;
    case 5: // экран проведения регулирования
      //Serial.print("Текущее время: ");
      //Serial.println(millis() - timer);
      if (millis() - TIMER >= PERIOD) { // отборажение значений термопары 2 раза в секунду
        
        // обработчик действий для термопары
        T_current = thermocouple.readCelsius(); // пересчёт на текущую температуру, в эту переменную будет записываться значение с термодатчика (термопары)
        screen_Experiment();
        
        do {
          TIMER += PERIOD;
          if (TIMER < PERIOD) break; // переполнение uint32_t
        } while (TIMER < millis() - PERIOD); // защита от пропуска шага
      }
      
      // отработка нажатия на кнопку с переходом в главное меню
      currentButton = debounce(lastButton); // если было LOW, то станет HIGH и наоборот
      if (lastButton == LOW && currentButton == HIGH){ // если кнопка была нажата, то...
        screenState = 0;
        ledOn = !ledOn;
        screen_Main_Menu(); // показать главное меню
      }
      lastButton = currentButton; // сменить состояние кнопки

      // отработка сигнализации раз в секунду
      if ((millis()- timer)/60000 >= timer_set && millis() - t >= 1000){ // если текущее время превысило установленное и текущее от прошлого отличается на 1с, то...
         t = millis(); // обновить состояние прошлого времени на текущее
         tone(soundPin, 1000, 300); // включать сигналиизацию с частотой 1000 Гц раз в секунду на 300 мс
         noTone; // отключать сигналку
      }

      // терморегулирование с использованием ПИД
      regulator.input = T_current; // сообщаем регулятору текущую температуру
      analogWrite(ledPin, regulator.getResultTimer(T_set, T_current));

      Serial.println("$");
      Serial.println(T_current);
      Serial.println(";");
  }
}

//---------------------------------------------------------------------------------Экран главного меню---------------------------------------------------------------------------------------

void screen_Main_Menu() { // случай, когда screenState = 0
  lcd.print("                "); // очистка дисплея
  lcd.setCursor(0, 0);
  lcd.print(" Temperature,\1C ");
  lcd.setCursor(0, 1);
  lcd.print("Set="); // кручением энкодера будет выставляться нужная температура; короткое нажатие энкодера подтвердит установку и вернет в меню температуры, а длинное - меню выбора коэф-в
  lcd.print(T_set); // переменная, в которую динамически будет вписываться полученное значение с вращения энкодера
  lcd.print("   ");
  lcd.setCursor(8, 1);
  lcd.print("Now="); // отображение реальной температуры
  lcd.print(T_current); // отображение переменной со значением, динамически полученным с термопары
  lcd.print("   ");
}

//-------------------------------------------------------------------------------Экран установки таймера-------------------------------------------------------------------------------------

void screen_Set_Timer() { // случай, когда screenState = 1
  lcd.print("                "); // очистка дисплея
  lcd.setCursor(0, 0);
  lcd.print("   Timer, min   ");
  lcd.setCursor(0, 1);
  lcd.print("   t="); // кручением энкодера будет выставляться нужное время; короткое нажатие энкодера откроет меню настроек таймера, а длинное - меню выбора коэф-в ПИД
  lcd.print(timer_set); // переменная, в которую динамически будет вписываться полученное значение с вращения энкодера
  lcd.print("min     ");
}

//--------------------------------------------------------------------------Экран настройки коэффициентов ПИД--------------------------------------------------------------------------------

void screen_Set_P() { // случай, когда screenState = 2
  lcd.print("                "); // очистка дисплея
  lcd.setCursor(0, 0);
  lcd.print("PID coefficients");
  lcd.setCursor(0, 1);
  lcd.print("Kp="); // кручением энкодера будет выставляться нужное значение кэфа; короткое нажатие энкодера переведет курсор к установке следующего кэфа, а длинное вернет в главное меню
  lcd.print(regulator.kp); // переменная, в которую динамически будет вписываться полученное значение с вращения энкодера (точность - до сотых)
  lcd.print("         ");
}
void screen_Set_I() { // случай, когда screenState = 3
  lcd.print("                "); // очистка дисплея
  lcd.setCursor(0, 0);
  lcd.print("PID coefficients");
  lcd.setCursor(0, 1);
  lcd.print("Ki="); // кручением энкодера будет выставляться нужное значение кэфа; короткое нажатие энкодера переведет курсор к установке следующего кэфа, а длинное вернет в главное меню
  lcd.print(regulator.ki); // переменная, в которую динамически будет вписываться полученное значение с вращения энкодера (точность - до сотых)
  lcd.print("         ");
}
void screen_Set_D() { // случай, когда screenState = 4
  lcd.print("                "); // очистка дисплея
  lcd.setCursor(0, 0);
  lcd.print("PID coefficients");
  lcd.setCursor(0, 1);
  lcd.print("Kd="); // кручением энкодера будет выставляться нужное значение кэфа; короткое нажатие энкодера переведет курсор к установке следующего кэфа, а длинное вернет в главное меню
  lcd.print(regulator.kd); // переменная, в которую динамически будет вписываться полученное значение с вращения энкодера (точность - до сотых)
  lcd.print("         ");
}

//----------------------------------------------------------------------------Экран проведения эксперимента----------------------------------------------------------------------------------

void screen_Experiment(){ // случай, когда screenState = 5
  lcd.print("                "); // очистка дисплея
  lcd.setCursor(0, 0);
  lcd.print(" Regulation...  ");
  lcd.print("Set="); // в этом экране действия энкодера не обрабатываются, так что по идее он не должен срабатывать
  lcd.print(T_set); // отображение установленной температуры
  lcd.print("   ");
  lcd.setCursor(8, 1);
  lcd.print("Now="); // отображение реальной температуры
  lcd.print(T_current); // отображение переменной со значением, динамически полученным с термопары
  lcd.print("   ");
}

//------------------------------------------------------------------------------Устранение дребезга кнопки-----------------------------------------------------------------------------------

boolean debounce(boolean last){
  boolean current = digitalRead(On_Off_Button);
  if (last != current){ // если переданное в функцию значение кнопки не равно только что считанному значеню, то...
    delay(10); // сделать задержку в 10 мс
    current = digitalRead(On_Off_Button); // и снова считать значение кнопки: HIGH или LOW
  }
  return current; // вернуть это считанное HIGH или LOW
}
